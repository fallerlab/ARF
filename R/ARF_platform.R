
# Copyright (C) 2023  Ferhat Alkan
#
#   This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

#' Read the input tsv file for sample data
#' @description This function allows you to read the tab-seperated ARF-samples file, returning a dataframe.
#' @param samplesFile Sample data file that describes file locations and sample groupings.
#' @keywords Reader Input Samples
#' @export
#' @examples
#' read_ARF_samples_file("samples.txt")
#' read_ARF_samples_file("samples.tsv")
read_ARF_samples_file <- function(samplesFile){
  samples_df <- read.csv(file = samplesFile, header = TRUE, sep = "\t", comment.char = "#", stringsAsFactors = FALSE)
  rownames(samples_df) <- samples_df[,1]
  return(samples_df)
}

#' Organism Check
#' @description Check if the organism is valid for analysis in ARF.
#' @param organism Organism abbrevation. Pass "hs" for human, "mm" for mouse, and "sc" for yeast.
#' @keywords ARF Organism dripARF
#' @export
#' @examples
#' ARF_check_organism("hs")
ARF_check_organism <- function(organism) {
  if (!(organism %in% c("hs","mm"))) {
    #,"rm","op","ch"))) {
    
    message("Choose a valid organism. hs (Homo sapiens, human), mm (Mus musculus, mouse),
          or run ARF_parse_PDB_ribosome() with your PDB id and pass its output file to the required function.\n")
    
    ribosome_PDBs <- list(plant=c("8B2L"), tomato=c("7QIZ"), maize=c("4V7E"),
                          Staphylococcus_aureus=c("6S0X","6S13"),
                          Bacillus_subtilis=c("3J9W"),
                          ecoli=c("4V9D","7UG7","7OTC","7TOS","6XZA","6XZB","7K00"),
                          thermophilus=c("6QNQ","6QNR","4V8P","4BTS"),
                          yeast=c("5M1J","4V88","7NRD","7NRC","6SNT","7TOP","7TOO","6T4Q","6T7I","6T7T"),
                          human=c("6QZP", "6Y0G", "6Y2L", "6Y57","5AJ0","7F5S","7TQL","4V6X"),
                          rabbit=c("7QWQ","7QWS","7QWR","7ZJX","7ZJW","7UCK","7UCJ","7TOR","7TOQ"),
                          drosophila=c("4V6W","6XU6")
                          )
    
    # print("Choose a valid organism. hs (Homo sapiens, human), mm (Mus musculus, mouse), rm (rhesus macaque, Macaca mulatta),
    #       op (grey short-tailed opossum, Monodelphis domestica), ch (chicken, red junglefowl, Gallus gallus) etc.")
    return(FALSE)
  }
  return(TRUE)
}

#' Parse 3D Ribosome data from PDB!
#' @description Parse 3D ribosome data 
#' @param species ID for the species to be analyzed, i.e. human
#' @param PDBid ID for the 3D structure, i.e. "4V6X" for human
#' @param PDB_file CIF file for the 3D ribosome, optional
#' @param rRNAs_file rRNAs file for the 3D ribosome, (must have been generated by ARF) optional
#' @param PDB_chains_2_RP_nomenclature Alternative data.frame that maps chain IDs to RP names and new nomenclature. Required columns are ID, RPname, RP_new, chainID.
#' @param download_directory Directory for downloads
#' @param method Which analysis to perform , default:"dripARF_minDistances" which calculates rRNA-RP min distances 
#' @param outprefix Prefix for the file to save results within
#' @param duplication_resolve How do we resolve duplicated chains (Default take the min distance)
#' @keywords 3D ribosome analysis using PDB file
#' @export
#' @examples
#' ARF_parse_PDB_ribosome("4V6X")
ARF_parse_PDB_ribosome <- function(species, PDBid, PDB_file=NULL, rRNAs_file=NULL, PDB_chains_2_RP_nomenclature=NULL,
                                   download_directory=getwd(), method="dripARF_minDistances", out_prefix="Ribosome.3D",
                                   duplication_resolve=min) {
  
  # dplyr hack for %>%
  `%>%` <- magrittr::`%>%`
  
  # For resolving nomenclature
  if(!is.null(PDB_chains_2_RP_nomenclature)) {
    chainData <- PDB_chains_2_RP_nomenclature
    if(sum(c("RP_new","RP_name","chainID")%in%colnames(chainData))!=3)
      stop(paste("Given nomenclature data.frame is incomplete."))
  } else if(PDBid %in% ARFcollide:::RP_nomenclature_map$PDB_id){
    chainData <- ARFcollide:::RP_nomenclature_map %>% dplyr::filter(PDB_id==PDBid)
  } else
    stop(paste("PDB_id", PDB_id, "is not within the default nomenclature, please provide nomenclature data.frame for this run."))
  
  # do we need to read in the cif?
  if (is.null(PDB_file)){
    #bio3d::get.pdb(ids = c(PDBid), format = 'cif')
    PDB_file <- paste0(download_directory,"/",PDBid,".cif")
    # bio3d::get.seq(ids = c(PDBid), outfile = seq_file, db = "pdb")
    utils::download.file(paste0("https://files.rcsb.org/download/",PDBid,".cif"),PDB_file)
  }
  if (is.null(rRNAs_file)){
    utils::download.file(paste0("https://www.rcsb.org/fasta/entry/",PDBid),paste0(download_directory,"/",PDBid,".fasta"))
    seq_set <- Biostrings::readBStringSet(filepath = paste0(download_directory,"/",PDBid,".fasta"))

    seqs <- data.frame(do.call(rbind, strsplit(names(seq_set), split = "|",fixed=T)),stringsAsFactors = F)
    colnames(seqs) <- c("ID","chain_info","RP","organism")
    seqs$chainID <- sapply(seqs$chain_info, 
                           FUN = function(x){
                             split_out <- c()
                             splittedx <- strsplit(x,split = ",",fixed = T)[[1]]
                             for (split in splittedx){
                               if(grepl(pattern = "auth", x = split, fixed = T)){
                                 splitted <- strsplit(gsub(pattern = "\\[|\\]",replacement = " ",split), split = " ", fixed=T)[[1]]
                                 newx <- splitted[which(splitted=="auth")+1]
                               }else{
                                 newx <- gsub(pattern = "Chains*\\s*", replacement = '', split)
                               }
                               split_out <- c(split_out, newx)
                             }
                             return(paste(unique(split_out),collapse = ","))
                           })
    seqs$chainType <- sapply(seqs$chainID, 
                              FUN = function(x){
                                split_out <- c()
                                splittedx <- strsplit(x,split = ",",fixed = T)[[1]]
                                for (split in splittedx){
                                  if ((split!="") && (sum(grepl(chainData$chainID, pattern = split,fixed = T))>0)) {
                                    split_out <- c(split_out,
                                                   chainData$RP_new[which(grepl(chainData$chainID,pattern = split,fixed = T))])}
                                }
                                return(paste(unique(split_out),collapse = ","))
                              })
    rRNAs_indexes <- which(grepl(pattern = "rRNA", x = seqs$chainType, fixed = T))
    rRNA_seq_set <- Biostrings::BStringSet(seq_set[rRNAs_indexes])
    names(rRNA_seq_set) <- seqs$chainType[rRNAs_indexes]
    Biostrings::writeXStringSet(rRNA_seq_set,paste0(download_directory,"/",PDBid,".rRNAs.fasta"))
  } else{
    rRNA_seq_set <- Biostrings::readBStringSet(rRNAs_file)
  }
  
  message("Starting 3D analysis!\n")
  
  # which RNA atom to use - N1 is a good choice
  RNA_atom <- "N1"
  ## Read in PDB file (of ribosome) ##
  PDB_data <- bio3d::read.cif(PDB_file)
  # make a dataframe of all the atoms
  PDB_dataframe <- data.frame(PDB_data[["atom"]],stringsAsFactors = F)
  
  # add chain data to PDB dataframe
  chainData_resolved <- NULL
  for (i in 1:dim(chainData)[1]){
    for (split in strsplit(x = chainData$chainID[i], split = ",", fixed = T))
      chainData_resolved <- rbind(chainData_resolved, data.frame(RP=chainData$RP_new[i], chain=split, stringsAsFactors = F))
  }
  PDB_dataframe <- PDB_dataframe %>% 
    dplyr::left_join(chainData_resolved)
  
  # and just alpha carbon atoms
  alphaCarbons <- dplyr::filter(PDB_dataframe, elety == "CA") %>%
    dplyr::select(x, y, z, RP, protein_chain=chain)
  
  # and and chosen reference atom
  rRNA_data <- dplyr::filter(PDB_dataframe, elety == RNA_atom) %>%
    dplyr::select(x, y, z, RP, resno, RNA_chain=chain)%>%
    dplyr::filter(RP%in%names(rRNA_seq_set))
  
  message("Cif file preprocessing done!\n")
  ########## find distances ############
  # Iterate through all RNA atom
  FinalData <- do.call(dplyr::bind_rows, 
                       lapply(1:nrow(rRNA_data), 
                              FUN = function(k){
                                if(k %% 100 == 1){
                                  cat(paste("\rCalculating RP-rRNA distances %", round(100*k/nrow(rRNA_data))))
                                  flush.console() 
                                }
                                
                                rna_x <- rRNA_data$x[k]
                                rna_y <- rRNA_data$y[k]
                                rna_z <- rRNA_data$z[k]
                                RNA_res <- rRNA_data$resno[k]
                                RNA <- rRNA_data$RP[k]
                                RNA_chain <- rRNA_data$RNA_chain[k]
                                
                                filtered_distances <- alphaCarbons %>% 
                                  dplyr::mutate(distance = ((x-rna_x)^2 + (y-rna_y)^2 + (z-rna_z)^2)^(0.5)) %>%
                                  dplyr::group_by(protein_chain) %>%
                                  dplyr::filter(distance == min(distance)) %>%
                                  dplyr::mutate(RNA_residue = RNA_res,
                                         RNA_chain = RNA_chain,
                                         RNA_molecule = RNA)
                                
                                return(filtered_distances)
                              }))
  FinalData_clean <- FinalData[,which(!colnames(FinalData)%in%c("x","y","z"))]%>%
    dplyr::filter(RP!="",RNA_molecule!="")%>%
    dplyr::group_by(RP, RNA_molecule, RNA_residue)%>%
    dplyr::summarize(distance=duplication_resolve(distance))%>%
    dplyr::ungroup()%>%dplyr::arrange(RP,RNA_molecule,RNA_residue)
  
  readr::write_csv(FinalData_clean, paste0(out_prefix,".",PDBid, ".ARF.minimum_distances.csv"))
  
  RP_proximity_df <- reshape2::dcast(FinalData_clean, RNA_molecule+RNA_residue~RP, 
                                     value.var="distance", fun.aggregate = duplication_resolve)
  colnames(RP_proximity_df)[1:2] <- c("rRNA","resno")
  RP_proximity_df[RP_proximity_df == -Inf] <- NA
  RP_proximity_df[RP_proximity_df == Inf] <- NA
  rownames(RP_proximity_df) = paste(RP_proximity_df$rRNA, RP_proximity_df$resno, sep = "_")
  
  readr::write_csv(RP_proximity_df, paste0(out_prefix,".",PDBid, ".ARF.minDist_matrix.csv"))
  return(RP_proximity_df)
}


#' Convert 3D Ribosome distance file to target organism through rRNA alignments!
#' @description Align rRNAs from source and target organism, then, convert source species 3D ribosome data accordingly
#' @param source_distance_file XXX.ARF.minimum_distances.csv file generated with ARF_parse_PDB_ribosome() for the source 3D Ribosome
#' @param source_rRNAs_fasta Fasta file for the rRNAs of the source organism.
#' @param target_species ID for the target species, i.e. mm, sc, etc. 
#' @param target_rRNAs_fasta Fasta file for the rRNAs of the target organism. Same file used in rRNA fragment alignment.
#' @param rRNA_pairs List of rRNA ID pairs matching source and target rRNAs i.e. list(c("human_28S","mouse_28S"), etc. ).
#' @param source_positions List of position vectors to convert (Alternative input)
#' @param type Which conversion to perform (Currently distances or positionset only)
#' @keywords 3D ribosome analysis using PDB file
#' @export
#' @examples
#' ARF_convert_ribosome3D_rRNA_pos()
ARF_convert_Ribo3D_pos <- function(source_distance_file, source_rRNAs_fasta, 
                                   target_species, target_rRNAs_fasta, rRNA_pairs=list(), 
                                   source_positions=NULL, type="distances") {
  # dplyr hack for %>%
  `%>%` <- magrittr::`%>%`
  
  source_rRNAs <- Biostrings::readBStringSet(file = source_rRNAs_fasta,use.names = T)
  target_rRNAs <- Biostrings::readBStringSet(file = target_rRNAs_fasta,use.names = T)
  names(source_rRNAs) <- sapply(sapply(names(source_rRNAs),strsplit,split=" ",fixed=T),"[",1)
  names(target_rRNAs) <- sapply(sapply(names(target_rRNAs),strsplit,split=" ",fixed=T),"[",1)
  
  # Add missing rRNA pairs with the same name
  for (rRNA in names(target_rRNAs)){
    if ((!rRNA%in%unlist(rRNA_pairs)) && (rRNA%in%names(source_rRNAs)))
      rRNA_pairs <- append(rRNA_pairs, list(c(rRNA,rRNA)))
  }
  rRNA_s2t <- sapply(rRNA_pairs,"[",2)
  names(rRNA_s2t) <- sapply(rRNA_pairs,"[",1)
  
  # list of transformation vectors
  s_2_t <- list()
  for (pair in rRNA_pairs) {
    rRNAs <- source_rRNAs[pair[1]]
    alignment <- strsplit(as.character(msa::msaClustalW(Biostrings::RNAStringSet(append(rRNAs,target_rRNAs[pair[2]])))@unmasked),
                          split="")
    # Read the alignment into S2T vector 
    s_2_t[[pair[1]]] <- rep(NA,length(alignment[[1]])) 
    spos <- 0
    tpos <- 0
    for (i in 1:length(alignment[[1]])){
      if (alignment[[2]][i]!="-") {tpos=tpos+1}
      if (alignment[[1]][i]!="-") {
        spos = spos+1
        if (alignment[[2]][i]!="-") {s_2_t[[pair[1]]][spos] <- tpos }
      }
    }
  }
  
  if (type=="distances") {
    source_distance_df <- read.csv2(source_distance_file,header = TRUE,sep = ",",stringsAsFactors = FALSE)
    target_distance_df <- NULL

    for (pair in rRNA_pairs) {
      source_temp_df <- source_distance_df%>%dplyr::filter(RNA_molecule==pair[1])%>%dplyr::mutate(distance=as.numeric(distance))
      source_residues <- unique(source_temp_df$RNA_residue)
      target_residues <- s_2_t[[pair[1]]][source_residues]
      
      # take all source positions and transform using s2t vector
      target_temp_df <- source_temp_df%>%dplyr::filter(RNA_residue%in%source_residues[!is.na(target_residues)])%>%
        dplyr::mutate(RNA_residue=s_2_t[[pair[1]]][RNA_residue], RNA_molecule=pair[2])
      
      # find source noVal intervals
      vec <- which(!(1:max(source_temp_df$RNA_residue))%in%source_temp_df$RNA_residue)  
      x <- replace(NA, vec, vec)
      l <- split(x, with(rle(is.na(x)), rep(seq.int(length(lengths)), lengths)))
      source_noVal_intervals <- Filter(Negate(anyNA), l)
      
      # find target noVal intervals
      vec <- which(!(1:max(target_temp_df$RNA_residue))%in%target_temp_df$RNA_residue)
      x <- replace(NA, vec, vec)
      l <- split(x, with(rle(is.na(x)), rep(seq.int(length(lengths)), lengths)))
      target_noVal_intervals <- Filter(Negate(anyNA), l)
      
      rm(x,l,vec)
      lengths(source_noVal_intervals)
      lengths(target_noVal_intervals[lengths(target_noVal_intervals)>=5])
      
      # For each target noVal interval less than 5, create values with linear change
      for (noVal_interval in target_noVal_intervals[lengths(target_noVal_intervals)<5]){
        min_temp_df <- target_temp_df%>%dplyr::filter(RNA_residue==min(noVal_interval)-1)%>%
          dplyr::arrange(RP)
        max_temp_df <- target_temp_df%>%dplyr::filter(RNA_residue==max(noVal_interval)+1)%>%
          dplyr::arrange(RP)
        step <- (max_temp_df$distance - min_temp_df$distance) / length(noVal_interval+1)
        for (i in 1:length(noVal_interval+1)){
          temp_df <- min_temp_df%>%dplyr::mutate(RNA_residue=RNA_residue+i)
          temp_df$distance <- temp_df$distance + (i*step)
          target_temp_df <- rbind(target_temp_df, temp_df)
        }
      }
      target_distance_df <- rbind(target_distance_df, target_temp_df)
    }
    
    target_distance_df <- target_distance_df%>%dplyr::arrange(RP,RNA_molecule,RNA_residue)
    readr::write_csv(target_distance_df, paste(gsub(pattern = ".csv$",replacement = "",source_distance_file),
                                               target_species,"converted.csv",sep="."))
    
    RP_proximity_df <- reshape2::dcast(target_distance_df, RNA_molecule+RNA_residue~RP, 
                                       value.var="distance",fun.aggregate = min)
    colnames(RP_proximity_df)[1:2] <- c("rRNA","resno")
    RP_proximity_df[RP_proximity_df == -Inf] <- NA
    RP_proximity_df[RP_proximity_df == Inf] <- NA
    rownames(RP_proximity_df) = paste(RP_proximity_df$rRNA, RP_proximity_df$resno, sep = "_")
    
    readr::write_csv(RP_proximity_df,paste(gsub(pattern = ".ARF.minimum_distances.csv$",
                                                replacement = ".ARF.minDist_matrix",source_distance_file),
                                           target_species,"converted.csv",sep="."))
    return(RP_proximity_df)
  } else if(type=="positionset") {
    target_positions <- list()
    for (setid in names(source_positions)){
      posset <- source_positions[[setid]]
      target_positions[[setid]] <- c()
      
      rRNAs_in_set <- sapply(strsplit(posset,split = "_[0-9]*$"),"[[",1)
      pos_in_set <- unname(sapply(posset, FUN=function(x){l <- strsplit(x, split = "_",fixed = T)[[1]]; return(as.numeric(l[length(l)]))}))

      for(rRNA in unique(rRNAs_in_set)){
        source_residues <- pos_in_set[rRNAs_in_set==rRNA]
        target_residues <- s_2_t[[rRNA]][source_residues]
        target_positions[[setid]] <- append(target_positions[[setid]], paste(rRNA_s2t[rRNA],target_residues[!is.na(target_residues)],sep = "_"))
      }
    }
    return(target_positions)
  }
}

